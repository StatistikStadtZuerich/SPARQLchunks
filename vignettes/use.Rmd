---
title: "SPARQL chunks and queries"
output: rmarkdown::html_vignette
author: AndrÃ© Ourednik - https://ourednik.info
date: 2022-06-01
vignette: >
  %\VignetteIndexEntry{SPARQL chunks and queries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This package allows you to query SPARQL endpoints in two different ways: 

1. Run SPARQL chunks in Rmarkdown files. 
2. Use inline functions to send SPARQL queries to a user-defined endpoint and retrieve data in _dataframe_ form (`sparql2df`) or _list_ form (`sparql2list`). 

Endpoints can be reached from behind corporate firewalls on Windows machines thanks to automatic proxy detection. See [Execute SPARQL chunks in R Markdown](https://ourednik.info/maps/2021/12/14/execute-sparql-chunks-in-r-markdown/).

## Installation

Most users can install by running this command 

```r
install_github("aourednik/SPARQLchunks")
```

If you are behind a corporate firewall on a Windows machine, direct access to GitHub might be blocked. If that is your case, run this installation code instead:

```r
proxy_url <- curl::ie_get_proxy_for_url("https://github.com")
httr::set_config(httr::use_proxy(proxy_url))
install_url("https://github.com/aourednik/SPARQLchunks/archive/refs/heads/master.zip")
```

## Use

To use the full potential of the package you need to load the library and _tell knitr that a SPARQL engine exists_: 

```{r setup, include=FALSE}
library(SPARQLchunks)
knitr::knit_engines$set(sparql = SPARQLchunks::eng_sparql)
```

Once you have done so, you can run SPARQL chunks:

### Chunks

#### Retrieve a dataframe

_output.var_: the name of the data.frame you want to store the results in

_endpoint_: the URL of the SPARQL endpoint

Example 1 (Swiss administration endpoint)

````markdown
`r ''````{sparql output.var="queryres_csv", endpoint="https://lindas.admin.ch/query"}
PREFIX schema: <http://schema.org/>
SELECT * WHERE {
  ?sub a schema:DataCatalog .
  ?subtype a schema:DataType .
}
```
````

Example 2 (WikiData endpoint):

````markdown
`r ''````{sparql output.var="res.df", endpoint="https://query.wikidata.org/sparql"}
SELECT DISTINCT ?item ?itemLabel ?country ?countryLabel ?linkTo ?linkToLabel
WHERE {
    ?item wdt:P1142 ?linkTo .
    ?linkTo wdt:P31 wd:Q12909644 .
    VALUES ?type { wd:Q7278  wd:Q24649 }
    ?item wdt:P31 ?type .
    ?item wdt:P17 ?country .
    MINUS { ?item wdt:P576 ?abolitionDate }
    SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en" . }
}
```
````

####  Retrieve a list

_output.var_: the name of the list you want to store the results in

_endpoint_: the URL of the SPARQL endpoint

_output.type_ : when set to "list", retrieves a list (tree structure) instead of a dataframe 

````markdown
`r ''````{sparql output.var="queryres_list", endpoint="https://lindas.admin.ch/query", output.type="list"}
PREFIX schema: <http://schema.org/>
SELECT * WHERE {
  ?sub a schema:DataCatalog .
  ?subtype a schema:DataType .
}
```
````

### Inline code

In all cases, you need to define an endpoint and prepare a SPQRQL query. Queries can be multi-line:

```{r, eval=FALSE}
endpoint <- "https://lindas.admin.ch/query"
query <- "PREFIX schema: <http://schema.org/>
  SELECT * WHERE {
  ?sub a schema:DataCatalog .
  ?subtype a schema:DataType .
}"
```


#### Retrieve a data.grame

```{r, eval=FALSE}
result_df <- sparql2df(endpoint,query)
```


#### Retrieve a list

```{r, eval=FALSE}
result_list <- sparql2list(endpoint,query)
```


